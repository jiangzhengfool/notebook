> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/skyme/p/4651331.html)

什么是熵 (Entropy)
==============

简单来说，熵是表示物质系统状态的一种度量，用它老表征系统的无序程度。熵越大，系统越无序，意味着系统结构和运动的不确定和无规则；反之，，熵越小，系统越有序，意味着具有确定和有规则的运动状态。熵的中文意思是热量被温度除的商。负熵是物质系统有序化，组织化，复杂化状态的一种度量。

熵最早来原于**物理学**. 德国物理学家鲁道夫 · 克劳修斯首次提出熵的概念，用来表示任何一种能量在空间中分布的均匀程度，能量分布得越均匀，熵就越大。

1.  一滴墨水滴在清水中，部成了一杯淡蓝色溶液
2.  热水晾在空气中，热量会传到空气中，最后使得温度一致

更多的一些生活中的例子:

1.  熵力的一个例子是耳机线，我们将耳机线整理好放进口袋，下次再拿出来已经乱了。让耳机线乱掉的看不见的 “力” 就是熵力，耳机线喜欢变成更混乱。
2.  熵力另一个具体的例子是弹性力。一根弹簧的力，就是熵力。 胡克定律其实也是一种熵力的表现。
3.  万有引力也是熵力的一种 (热烈讨论的话题)。
4.  浑水澄清 [1]

[![](https://images0.cnblogs.com/blog/133059/201507/161450272353131.png)](http://images0.cnblogs.com/blog/133059/201507/161450265483975.png)

于是从微观看，熵就表现了这个系统所处状态的**不确定性程度**。香农，描述一个信息系统的时候就借用了熵的概念，这里熵表示的是这个信息系统的**平均信息量** **(****平均不确定程度****)**。

最大熵模型
=====

我们在投资时常常讲不要把所有的鸡蛋放在一个篮子里，这样可以降低风险。在信息处理中，这个原理同样适用。在数学上，这个原理称为最大熵原理 (the maximum entropy principle)。

让我们看一个拼音转汉字的简单的例子。假如输入的拼音是 "wang-xiao-bo"，利用语言模型，根据有限的上下文 (比如前两个词)，我们能给出两个最常见的名字“王小波” 和“王晓波 ”。至于要唯一确定是哪个名字就难了，即使利用较长的上下文也做不到。当然，我们知道如果通篇文章是介绍文学的，作家王小波的可能性就较大；而在讨论两岸关系时，台湾学者王晓波的可能性会较大。在上面的例子中，我们只需要综合两类不同的信息，即主题信息和上下文信息。虽然有不少凑合的办法，比如：分成成千上万种的不同的主题单独处理，或者对每种信息的作用加权平均等等，但都不能准确而圆满地解决问题，这样好比以前我们谈到的行星运动模型中的小圆套大圆打补丁的方法。在很多应用中，我们需要综合几十甚至上百种不同的信息，这种小圆套大圆的方法显然行不通。

数学上最漂亮的办法是最大熵 (maximum entropy) 模型，它相当于行星运动的椭圆模型。“最大熵”这个名词听起来很深奥，但是它的原理很简单，我们每天都在用。说白了，就是要保留全部的不确定性，将风险降到最小。

回到我们刚才谈到的拼音转汉字的例子，我们已知两种信息，第一，根据语言模型，wangxiao-bo 可以被转换成王晓波和王小波；第二，根据主题，王小波是作家，《黄金时代》的作者等等，而王晓波是台湾研究两岸关系的学者。因此，我们就可以建立一个最大熵模型，同时满足这两种信息。现在的问题是，这样一个模型是否存在。匈牙利著名数学家、信息论最高奖香农奖得主希萨（Csiszar）证明，对任何一组不自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一的。而且它们都有同一个非常简单的形式 -- 指数函数。下面公式是根据上下文（前两个词）和主题预测下一个词的最大熵模型，其中 w3 是要预测的词（王晓波或者王小波）w1 和 w2 是它的前两个字（比如说它们分别是 “出版”，和 “”），也就是其上下文的一个大致估计，subject 表示主题。

[![](https://images0.cnblogs.com/blog/133059/201507/161450287047116.jpg)](http://images0.cnblogs.com/blog/133059/201507/161450278762003.jpg)

我们看到，在上面的公式中，有几个参数 lambda 和 Z ，他们需要通过观测数据训练出来。最大熵模型在形式上是最漂亮的统计模型，而在实现上是最复杂的模型之一。

我们上次谈到用最大熵模型可以将各种信息综合在一起。我们留下一个问题没有回答，就是如何构造最大熵模型。我们已经所有的最大熵模型都是指数函数的形式，现在只需要确定指数函数的参数就可以了，这个过程称为模型的训练。

最原始的最大熵模型的训练方法是一种称为通用迭代算法 GIS(generalized iterative scaling) 的迭代 算法。GIS 的原理并不复杂，大致可以概括为以下几个步骤：  
1. 假定第零次迭代的初始模型为等概率的均匀分布。  
2. 用第 N 次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了实际的，就把相应的模型参数变小；否则，将它们便大。  
3. 重复步骤 2 直到收敛。

GIS 最早是由 Darroch 和 Ratcliff 在七十年代提出的。但是，这两人没有能对这种算法的物理含义进行很好地解释。后来是由数学家希萨（Csiszar) 解释清楚的，因此，人们在谈到这个算法时，总是同时引用 Darroch 和 Ratcliff 以及希萨的两篇论文。GIS 算法每次迭代的时间都很长，需要迭代很多次才能收敛，而且不太稳定，即使在 64 位计算机上都会出现溢出。因此，在实际应用中很少有人真正使用 GIS。大家只是通过它来了解最大熵模型的算法。  
    八十年代，很有天才的孪生兄弟的达拉皮垂 (Della Pietra) 在 IBM 对 GIS 算法进行了两方面的改进，提出了改进迭代算法 IIS（improved iterative scaling）。这使得最大熵模型的训练时间缩短了一到两个数量级。这样最大熵模型才有可能变得实用。即使如此，在当时也只有 IBM 有条件是用最大熵模型。

由于最大熵模型在数学上十分完美，对科学家们有很大的诱惑力，因此不少研究者试图把自己的问题用一个类似最大熵的近似模型去套。谁知这一近似，最大熵模型就变得不完美了，结果可想而知，比打补丁的凑合的方法也好不了多少。于是，不少热心人又放弃了这种方法。第一个在实际信息处理应用中验证了最大熵模型的优势的，是宾夕法尼亚大学马库斯的另一个高徒原 IBM 现微软的研究员拉纳帕提 (Adwait Ratnaparkhi)。拉纳帕提的聪明之处在于他没有对最大熵模型进行近似，而是找到了几个最适合用最大熵模型、而计算量相对不太大的自然语言处理问题，比如词性标注和句法分析。拉纳帕提成功地将上下文信息、词性（名词、动词和形容词等）、句子成分（主谓宾）通过最大熵模型结合起来，做出了当时世界上最好的词性标识系统和句法分析器。拉纳帕提的论文发表后让人们耳目一新。拉纳帕提的词性标注系统，至今仍然是使用单一方法最好的系统。科学家们从拉纳帕提的成就中，又看到了用最大熵模型解决复杂的文字信息处理的希望。

但是，最大熵模型的计算量仍然是个拦路虎。我在学校时花了很长时间考虑如何简化最大熵模型的计算量。终于有一天，我对我的导师说，我发现一种数学变换，可以将大部分最大熵模型的训练时间在 IIS 的基础上减少两个数量级。我在黑板上推导了一个多小时，他没有找出我的推导中的任何破绽，接着他又回去想了两天，然后告诉我我的算法是对的。从此，我们就建造了一些很大的最大熵模型。这些模型比修修补补的凑合的方法好不少。即使在我找到了快速训练算法以后，为了训练一个包含上下文信息，主题信息和语法信息的文法模型 (language model)，我并行使用了 20 台当时最快的 SUN 工作站，仍然计算了三个月。由此可见最大熵模型的复杂的一面。

最大熵模型，可以说是集简与繁于一体，形式简单，实现复杂。值得一提的是，在 Google 的很多产品中，比如机器翻译，都直接或间接地用到了最大熵模型。  
     讲到这里，读者也许会问，当年最早改进最大熵模型算法的达拉皮垂兄弟这些年难道没有做任何事吗？他们在九十年代初贾里尼克离开 IBM 后，也退出了学术界，而到在金融界大显身手。他们两人和很多 IBM 语音识别的同事一同到了一家当时还不大，但现在是世界上最成功对冲基金 (hedge fund) 公司 ---- 文艺复兴技术公司 (Renaissance Technologies)。我们知道，决定股票涨落的因素可能有几十甚至上百种，而最大熵方法恰恰能找到一个同时满足成千上万种不同条件的模型。达拉皮垂兄弟等科学家在那里，用于最大熵模型和其他一些先进的数学工具对股票预测，获得了巨大的成功。从该基金 1988 年创立至今，它的净回报率高达平均每年 34%。也就是说，如果 1988 年你在该基金投入一块钱，今天你能得到 200 块钱。这个业绩，远远超过股神巴菲特的旗舰公司伯克夏哈撒韦（Berkshire Hathaway)。同期，伯克夏哈撒韦的总回报是 16 倍。  
    值得一提的是，信息处理的很多数学手段，包括隐含马尔可夫模型、子波变换、贝叶斯网络等等，在华尔街多有直接的应用。由此可见，数学模型的作用。

HMM（**隐马尔可夫模型**）
================

**隐马尔可夫模型**（Hidden Markov Model，HMM）是统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。其难点是从可观察的参数中确定该过程的隐含参数。然后利用这些参数来作进一步的分析，例如模式识别。

是在被建模的系统被认为是一个马尔可夫过程与未观测到的（隐藏的）的状态的统计马尔可夫模型。

下面用一个简单的例子来阐述：

假设我手里有三个不同的骰子。第一个骰子是我们平常见的骰子（称这个骰子为 D6），6 个面，每个面（1，2，3，4，5，6）出现的概率是 1/6。第二个骰子是个四面体（称这个骰子为 D4），每个面（1，2，3，4）出现的概率是 1/4。第三个骰子有八个面（称这个骰子为 D8），每个面（1，2，3，4，5，6，7，8）出现的概率是 1/8。

[![](https://images0.cnblogs.com/blog/133059/201507/161450315321886.png)](http://images0.cnblogs.com/blog/133059/201507/161450305163828.png)

假设我们开始掷骰子，我们先从三个骰子里挑一个，挑到每一个骰子的概率都是 1/3。然后我们掷骰子，得到一个数字，1，2，3，4，5，6，7，8 中的一个。不停的重复上述过程，我们会得到一串数字，每个数字都是 1，2，3，4，5，6，7，8 中的一个。例如我们可能得到这么一串数字（掷骰子 10 次）：1 6 3 5 2 7 3 5 2 4

这串数字叫做可见状态链。但是在隐马尔可夫模型中，我们不仅仅有这么一串可见状态链，还有一串隐含状态链。在这个例子里，这串隐含状态链就是你用的骰子的序列。比如，隐含状态链有可能是：D6 D8 D8 D6 D4 D8 D6 D6 D4 D8

一般来说，HMM 中说到的马尔可夫链其实是指隐含状态链，因为隐含状态（骰子）之间存在转换概率（transition probability）。在我们这个例子里，D6 的下一个状态是 D4，D6，D8 的概率都是 1/3。D4，D8 的下一个状态是 D4，D6，D8 的转换概率也都一样是 1/3。这样设定是为了最开始容易说清楚，但是我们其实是可以随意设定转换概率的。比如，我们可以这样定义，D6 后面不能接 D4，D6 后面是 D6 的概率是 0.9，是 D8 的概率是 0.1。这样就是一个新的 HMM。

同样的，尽管可见状态之间没有转换概率，但是隐含状态和可见状态之间有一个概率叫做输出概率（emission probability）。就我们的例子来说，六面骰（D6）产生 1 的输出概率是 1/6。产生 2，3，4，5，6 的概率也都是 1/6。我们同样可以对输出概率进行其他定义。比如，我有一个被赌场动过手脚的六面骰子，掷出来是 1 的概率更大，是 1/2，掷出来是 2，3，4，5，6 的概率是 1/10。

[![](https://images0.cnblogs.com/blog/133059/201507/161450330639383.png)](http://images0.cnblogs.com/blog/133059/201507/161450321576527.png)

[![](https://images0.cnblogs.com/blog/133059/201507/161450345487598.png)](http://images0.cnblogs.com/blog/133059/201507/161450339544712.png)

其实对于 HMM 来说，如果提前知道所有隐含状态之间的转换概率和所有隐含状态到所有可见状态之间的输出概率，做模拟是相当容易的。但是应用 HMM 模型时候呢，往往是缺失了一部分信息的，有时候你知道骰子有几种，每种骰子是什么，但是不知道掷出来的骰子序列；有时候你只是看到了很多次掷骰子的结果，剩下的什么都不知道。如果应用算法去估计这些缺失的信息，就成了一个很重要的问题。这些算法我会在下面详细讲。

×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××  
      如果你只想看一个简单易懂的例子，就不需要往下看了。  
     ×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××  
    说两句废话，答主认为呢，要了解一个算法，要做到以下两点：会其意，知其形。答主回答的，其实主要是第一点。但是这一点呢，恰恰是最重要，而且很多书上不会讲的。正如你在追一个姑娘，姑娘对你说 “你什么都没做错！” 你要是只看姑娘的表达形式呢，认为自己什么都没做错，显然就理解错了。你要理会姑娘的意思，“你赶紧给我道歉！”这样当你看到对应的表达形式呢，赶紧认错，跪地求饶就对了。数学也是一样，你要是不理解意思，光看公式，往往一头雾水。不过呢，数学的表达顶多也就是晦涩了点，姑娘的表达呢，有的时候就完全和本意相反。所以答主一直认为理解姑娘比理解数学难多了。

回到正题，和 HMM 模型相关的算法主要分为三类，分别解决三种问题：  
 **1）知道骰子有几种（隐含状态数量），每种骰子是什么（转换概率），根据掷骰子掷出的结果（可见状态链），我想知道每次掷出来的都是哪种骰子（隐含状态链）。**  
      这个问题呢，在语音识别领域呢，叫做解码问题。这个问题其实有两种解法，会给出两个不同的答案。每个答案都对，只不过这些答案的意义不一样。第一种解法求最大似然状态路径，说通俗点呢，就是我求一串骰子序列，这串骰子序列产生观测结果的概率最大。第二种解法呢，就不是求一组骰子序列了，而是求每次掷出的骰子分别是某种骰子的概率。比如说我看到结果后，我可以求得第一次掷骰子是 D4 的概率是 0.5，D6 的概率是 0.3，D8 的概率是 0.2. 第一种解法我会在下面说到，但是第二种解法我就不写在这里了，如果大家有兴趣，我们另开一个问题继续写吧。

**2）还是知道骰子有几种****（隐含状态数量）****，每种骰子是什么****（转换概率）****，根据掷骰子掷出的结果****（可见状态链）****，我想知道掷出这个结果的概率。**  
      看似这个问题意义不大，因为你掷出来的结果很多时候都对应了一个比较大的概率。问这个问题的目的呢，其实是检测观察到的结果和已知的模型是否吻合。如果很多次结果都对应了比较小的概率，那么就说明我们已知的模型很有可能是错的，有人偷偷把我们的骰子給换了。

**3）知道骰子有几种****（隐含状态数量）****，不知道每种骰子是什么****（转换概率）****，观测到很多次掷骰子的结果****（可见状态链）****，我想反推出每种骰子是什么****（转换概率）****。**  
      这个问题很重要，因为这是最常见的情况。很多时候我们只有可见结果，不知道 HMM 模型里的参数，我们需要从可见结果估计出这些参数，这是建模的一个必要步骤。

问题阐述完了，下面就开始说解法。（0 号问题在上面没有提，只是作为解决上述问题的一个辅助）  
      0. 一个简单问题  
其实这个问题实用价值不高。由于对下面较难的问题有帮助，所以先在这里提一下。  
知道骰子有几种，每种骰子是什么，每次掷的都是什么骰子，根据掷骰子掷出的结果，求产生这个结果的概率。

[![](https://images0.cnblogs.com/blog/133059/201507/161450356269168.png)](http://images0.cnblogs.com/blog/133059/201507/161450350489511.png)

解法无非就是概率相乘：  
![](http://zhihu.com/equation?tex=P%3DP%28D6%29%2AP%28D6%5Crightarrow+1%29%2AP%28D6%5Crightarrow+D8%29%2AP%28D8%5Crightarrow+6%29%2AP%28D8%5Crightarrow+D8%29%2AP%28D8%5Crightarrow+3%29)  
![](http://zhihu.com/equation?tex=%3D%5Cfrac%7B1%7D%7B3%7D+%2A%5Cfrac%7B1%7D%7B6%7D+%2A%5Cfrac%7B1%7D%7B3%7D+%2A%5Cfrac%7B1%7D%7B8%7D+%2A%5Cfrac%7B1%7D%7B3%7D+%2A%5Cfrac%7B1%7D%7B8%7D+)  
**1. 看见不可见的，破解骰子序列**  
      这里我说的是第一种解法，解最大似然路径问题。  
      举例来说，我知道我有三个骰子，六面骰，四面骰，八面骰。我也知道我掷了十次的结果（1 6 3 5 2 7 3 5 2 4），我不知道每次用了那种骰子，我想知道最有可能的骰子序列。

其实最简单而暴力的方法就是穷举所有可能的骰子序列，然后依照第零个问题的解法把每个序列对应的概率算出来。然后我们从里面把对应最大概率的序列挑出来就行了。如果马尔可夫链不长，当然可行。如果长的话，穷举的数量太大，就很难完成了。  
      另外一种很有名的算法叫做 Viterbi algorithm. 要理解这个算法，我们先看几个简单的列子。  
      首先，如果我们只掷一次骰子：

[![](https://images0.cnblogs.com/blog/133059/201507/161450366738982.png)](http://images0.cnblogs.com/blog/133059/201507/161450361262083.png)

看到结果为 1. 对应的最大概率骰子序列就是 D4，因为 D4 产生 1 的概率是 1/4，高于 1/6 和 1/8.  
      把这个情况拓展，我们掷两次骰子：

[![](https://images0.cnblogs.com/blog/133059/201507/161450373608137.png)](http://images0.cnblogs.com/blog/133059/201507/161450369701425.png)

结果为 1，6. 这时问题变得复杂起来，我们要计算三个值，分别是第二个骰子是 D6，D4，D8 的最大概率。显然，要取到最大概率，第一个骰子必须为 D4。这时，第二个骰子取到 D6 的最大概率是  
![](http://zhihu.com/equation?tex=P2%28D6%29%3DP%28D4%29%2AP%28D4%5Crightarrow+1%29%2AP%28D4%5Crightarrow+D6%29%2AP%28D6%5Crightarrow+6%29)  
![](http://zhihu.com/equation?tex=%3D%5Cfrac%7B1%7D%7B3%7D+%2A%5Cfrac%7B1%7D%7B4%7D+%2A%5Cfrac%7B1%7D%7B3%7D+%2A%5Cfrac%7B1%7D%7B6%7D)  
      同样的，我们可以计算第二个骰子是 D4 或 D8 时的最大概率。我们发现，第二个骰子取到 D6 的概率最大。而使这个概率最大时，第一个骰子为 D4。所以最大概率骰子序列就是 D4 D6。  
继续拓展，我们掷三次骰子：

[![](https://images0.cnblogs.com/blog/133059/201507/161450394547765.png)](http://images0.cnblogs.com/blog/133059/201507/161450384543938.png)

同样，我们计算第三个骰子分别是 D6，D4，D8 的最大概率。我们再次发现，要取到最大概率，第二个骰子必须为 D6。这时，第三个骰子取到 D4 的最大概率是![](http://zhihu.com/equation?tex=P3%28D4%29%3DP2%28D6%29%2AP%28D6%5Crightarrow+D4%29%2AP%28D4%5Crightarrow+3%29)  
![](http://zhihu.com/equation?tex=%3D%5Cfrac%7B1%7D%7B216%7D+%2A%5Cfrac%7B1%7D%7B3%7D+%2A%5Cfrac%7B1%7D%7B4%7D)  
      同上，我们可以计算第三个骰子是 D6 或 D8 时的最大概率。我们发现，第三个骰子取到 D4 的概率最大。而使这个概率最大时，第二个骰子为 D6，第一个骰子为 D4。所以最大概率骰子序列就是 D4 D6 D4。

写到这里，大家应该看出点规律了。既然掷骰子一二三次可以算，掷多少次都可以以此类推。我们发现，我们要求最大概率骰子序列时要做这么几件事情。首先，不管序列多长，要从序列长度为 1 算起，算序列长度为 1 时取到每个骰子的最大概率。然后，逐渐增加长度，每增加一次长度，重新算一遍在这个长度下最后一个位置取到每个骰子的最大概率。因为上一个长度下的取到每个骰子的最大概率都算过了，重新计算的话其实不难。当我们算到最后一位时，就知道最后一位是哪个骰子的概率最大了。然后，我们要把对应这个最大概率的序列从后往前推出来。  
**2. 谁动了我的骰子？**  
      比如说你怀疑自己的六面骰被赌场动过手脚了，有可能被换成另一种六面骰，这种六面骰掷出来是 1 的概率更大，是 1/2，掷出来是 2，3，4，5，6 的概率是 1/10。你怎么办么？答案很简单，算一算正常的三个骰子掷出一段序列的概率，再算一算不正常的六面骰和另外两个正常骰子掷出这段序列的概率。如果前者比后者小，你就要小心了。  
      比如说掷骰子的结果是：  
[![](https://images0.cnblogs.com/blog/133059/201507/161450406884821.png)](http://images0.cnblogs.com/blog/133059/201507/161450402987108.png)

要算用正常的三个骰子掷出这个结果的概率，其实就是将所有可能情况的概率进行加和计算。同样，简单而暴力的方法就是把穷举所有的骰子序列，还是计算每个骰子序列对应的概率，但是这回，我们不挑最大值了，而是把所有算出来的概率相加，得到的总概率就是我们要求的结果。这个方法依然不能应用于太长的骰子序列（马尔可夫链）。  
      我们会应用一个和前一个问题类似的解法，只不过前一个问题关心的是概率最大值，这个问题关心的是概率之和。解决这个问题的算法叫做前向算法（forward algorithm）。  
首先，如果我们只掷一次骰子：

[![](https://images0.cnblogs.com/blog/133059/201507/161450419851092.png)](http://images0.cnblogs.com/blog/133059/201507/161450412515950.png)

看到结果为 1. 产生这个结果的总概率可以按照如下计算，总概率为 0.18：

[![](https://images0.cnblogs.com/blog/133059/201507/161450434381848.png)](http://images0.cnblogs.com/blog/133059/201507/161450427046706.png)

把这个情况拓展，我们掷两次骰子：

[![](https://images0.cnblogs.com/blog/133059/201507/161450445489876.png)](http://images0.cnblogs.com/blog/133059/201507/161450442206677.png)

看到结果为 1，6. 产生这个结果的总概率可以按照如下计算，总概率为 0.05：

[![](https://images0.cnblogs.com/blog/133059/201507/161450459079660.png)](http://images0.cnblogs.com/blog/133059/201507/161450450328560.png)

继续拓展，我们掷三次骰子：

[![](https://images0.cnblogs.com/blog/133059/201507/161450480322045.png)](http://images0.cnblogs.com/blog/133059/201507/161450469549473.png)

看到结果为 1，6，3. 产生这个结果的总概率可以按照如下计算，总概率为 0.03：

[![](https://images0.cnblogs.com/blog/133059/201507/161450513459200.png)](http://images0.cnblogs.com/blog/133059/201507/161450499388728.png)

同样的，我们一步一步的算，有多长算多长，再长的马尔可夫链总能算出来的。用同样的方法，也可以算出不正常的六面骰和另外两个正常骰子掷出这段序列的概率，然后我们比较一下这两个概率大小，就能知道你的骰子是不是被人换了。

Viterbi algorithm
=================

HMM（隐马尔可夫模型）是用来描述隐含未知参数的统计模型，举一个经典的例子：一个东京的朋友每天根据天气 {下雨，天晴} 决定当天的活动 {公园散步, 购物, 清理房间} 中的一种，我每天只能在 twitter 上看到她发的推“啊，我前天公园散步、昨天购物、今天清理房间了！”，那么我可以根据她发的推特推断东京这三天的天气。在这个例子里，显状态是活动，隐状态是天气。

任何一个 HMM 都可以通过下列五元组来描述：

```
:param obs:观测序列
:param states:隐状态
:param start_p:初始概率（隐状态）
:param trans_p:转移概率（隐状态）
:param emit_p: 发射概率 （隐状态表现为显状态的概率）
```

[![](https://images0.cnblogs.com/blog/133059/201507/161450536414597.jpg)](http://images0.cnblogs.com/blog/133059/201507/161450524231771.jpg)

伪码如下：

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

```
states = ('Rainy', 'Sunny')
 
observations = ('walk', 'shop', 'clean')
 
start_probability = {'Rainy': 0.6, 'Sunny': 0.4}
 
transition_probability = {
    'Rainy' : {'Rainy': 0.7, 'Sunny': 0.3},
    'Sunny' : {'Rainy': 0.4, 'Sunny': 0.6},
    }
 
emission_probability = {
    'Rainy' : {'walk': 0.1, 'shop': 0.4, 'clean': 0.5},
    'Sunny' : {'walk': 0.6, 'shop': 0.3, 'clean': 0.1},
}
```

[![](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")

#### 求解最可能的天气

求解最可能的隐状态序列是 HMM 的三个典型问题之一，通常用维特比算法解决。维特比算法就是求解 HMM 上的最短路径（-log(prob)，也即是最大概率）的算法。

稍微用中文讲讲思路，很明显，第一天天晴还是下雨可以算出来：

1.  定义 V[时间][今天天气] = 概率，注意今天天气指的是，前几天的天气都确定下来了（概率最大）今天天气是 X 的概率，这里的概率就是一个累乘的概率了。
    
2.      因为第一天我的朋友去散步了，所以第一天下雨的概率 V[第一天][下雨] = 初始概率 [下雨] * 发射概率 [下雨][散步] = 0.6 * 0.1 = 0.06，同理可得 V[第一天][天晴] = 0.24 。从直觉上来看，因为第一天朋友出门了，她一般喜欢在天晴的时候散步，所以第一天天晴的概率比较大，数字与直觉统一了。
    
3.  从第二天开始，对于每种天气 Y，都有前一天天气是 X 的概率 * X 转移到 Y 的概率 * Y 天气下朋友进行这天这种活动的概率。因为前一天天气 X 有两种可能，所以 Y 的概率有两个，选取其中较大一个作为 V[第二天][天气 Y] 的概率，同时将今天的天气加入到结果序列中
    
4.  比较 V[最后一天][下雨]和 [最后一天][天晴] 的概率，找出较大的哪一个对应的序列，就是最终结果。
    

算法的代码可以在 github 上看到，地址为：

[https://github.com/hankcs/Viterbi](https://github.com/hankcs/Viterbi "https://github.com/hankcs/Viterbi")

运行完成后根据 Viterbi 得到结果：

```
Sunny Rainy Rainy
```

Viterbi 被广泛应用到分词，词性标注等应用场景。