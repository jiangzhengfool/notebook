> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/u014313009/article/details/47406361) **本文着重介绍了红黑树的插入和删除操作，由于网上很多介绍红黑树的博文只介绍操作过程，而不解释为什么进行该操作，或者仅仅用 “符合红黑树的五个性质” 一带而过，令人费解。因此，本文在介绍各种插入和删除操作的同时，会详细解释各个操作的作用。希望本文能够帮助你快速理解红黑树的插入和删除过程。（本文图片来自维基百科，https://en.wikipedia.org/wiki/Red_black_tree）**

**1、定义**

红黑树是一种高度平衡的二叉搜索树，包含 5 个性质：

(1) 节点不是红的，就是黑的。

(2) 根节点是黑的。

(3) 所有叶子节点都是黑的（叶子是 NIL 节点）。

(4) 每个红色节点的两个子节点都是黑的。（从根到叶子节点的所有路径上都不能有两个连续的红色节点）

(5) 从任一节点到其每个叶节点的所有路径都包含相同数量的黑色节点。

  

![](https://img-blog.csdn.net/20150810223023508)  

           注意，红黑树是高度平衡，而不是绝对平衡。由性质 4、5 可知，两个子树的黑色节点数量相同，当一棵子树没有红色节点，而另一棵子树有尽可能多的红色节点时，两棵子树最大的高度差只有 2 倍。  
  
**2. 数据结构**   红黑树的每个节点都包含了四个基本属性，分别是颜色（默认是黑色）、父节点、左子结点、右子节点。以下摘自红黑树在 STL 的结构定义：  

> `typedef bool _Rb_tree_Color_type;` `const _Rb_tree_Color_type _S_rb_tree_red =` `false``;` `const _Rb_tree_Color_type _S_rb_tree_black =` `true``;`   `struct _Rb_tree_node_base` `{` `typedef _Rb_tree_Color_type _Color_type;` `typedef _Rb_tree_node_base* _Base_ptr;`   ** `_Color_type _M_color;`** ** `_Base_ptr _M_parent;`** ** `_Base_ptr _M_left;`** ** `_Base_ptr _M_right;`** ...... `};`

  
  
**3. 插入操作**   插入点应设为红色，不能是黑色。因为插入黑色点，将破坏性质 5。但如果插入点的父节点也是红色，不也破坏了性质 4？是的，但考虑到恢复性质 4 比恢复性质 5 更简单，因此插入红色节点。当性质被破坏时，通过重新着色和旋转进行恢复。为描述方便，插入节点为 N（红色），父节点为 P，祖父节点为 G，叔叔节点为 U。所有插入情况如下：  
   case 0.0：该树为空树，直接插入根节点，此时违反性质 2，将节点改为黑色即可。  
   case 0.1 : 插入点 N 的父节点 P 为黑色，不违反任何性质（注意，根据二叉查找树的性质，N 的两个子节点都为叶节点），结束。  
   **当父节点 P 为红色时，违反性质 4，分三种情况调整（此时 N 为红，P 为红，有 G 且 G 一定为黑）：**  
   **case 1****：**叔叔节点 U 为红，如图：  
![](https://img-blog.csdn.net/20150810223049870)

           **操作：**P、U 变为黑，G 变为红。    **解析：**子树恢复了性质 4，但是 G 的父节点可能为黑，也可能为红。如果 G 的父节点为黑，则结束；如果为红，就把 G 作为起始点，向上检索，根据 case1、2、3 继续处理。（如果处理到最后，根节点变为红色，则把根节点再改为黑色即可）  
   **case 2：**U 为黑，N 为 P 的左孩子，P 为 G 的左孩子（或者 N 为 P 的右孩子，P 为 G 的右孩子，即同向），如图：  
![](https://img-blog.csdn.net/20150810223118663)

        **操作**：P 和 G 交换颜色，并右旋。（对于 N、P 都为右情况，此处是左旋）    **解析：**P 变为黑色后，左子树恢复了性质 4；接着，右旋使 P 处于 G 最初的位置，而 G 变为红色后不影响右子树的黑色节点个数。结束。  
   **case 3：**U 为黑，N 为 P 的右孩子，P 为 G 的左孩子（或者 N 为 P 的左孩子，P 为 G 的右孩子，即反向），如图：  
![](https://img-blog.csdn.net/20150810223158692)

  
   **操作：**左旋。（对于 N 为左、P 为右的情况，此处是右旋）    **解析：**左旋后，P、N 交换了上下的位置，且都为左孩子，此时变成了 case 2，继续进行 case 2 的操作即可。  
  
  
**4. 删除操作**    二叉查找树的删除有个技巧：先查找到要删除的节点 X，然后找到它左子树的最大元素节点 N 或右子树的最小元素节点 N（N 最多只有一个非叶子节点），用 N 的值替换 X 的值；而 N 的位置则用它的子节点替换即可。为描述方便，N 为替换节点，P 为 N 的父节点，S 为 N 的兄弟节点，SL、SR 分别为 S 的左右子节点。具体删除情况分类如下：  
    case 0.0：N 为红色节点，那么 N 的两个子节点一定为 NIL（黑色），直接删除 N 即可，不违反任何性质。  
    case 0.1：N 为黑色节点，且有一个非叶子结点 M，那么 M 一定为红色，且两个子节点一定为 NIL，此时用 M 替换 N，将 M 的颜色改为黑即可。  
   **当 N 为黑，且两个子节点都为 NIL 时，删除 N 使通过 N 的路径少了一个黑色节点，破换了性质 5，分五种情况讨论：**   **case 1：**兄弟节点 S 为红（此时，P、SL、SR 一定为黑），如图：  
![](https://img-blog.csdn.net/20150810223225233)  
   **操作：**P 和 S 交换颜色，并左旋。    **解析：**该操作只是使 N 的父节点变为红色，但是通过 N 的路径仍然少了一个黑点，因此需要根据 case3、4、5 继续调整。  
   **case 2：**S、SL、SR、P 都为黑，如图：  
![](https://img-blog.csdn.net/20150810223255369)    **操作：**S 变为红。    **解析：**S 变为红之后，通过 S 的路径少了一个黑节点，使 P 左右子树的黑节点个数相等。但是通过 P 的路径比不通过 P 的路径少了一个黑色节点，因此要以 P 为起始点，向上递归处理。  
   **case 3：**S、SL、SR 都为黑，但 P 为红，如图：  
![](https://img-blog.csdn.net/20150810223337324)  
   **操作：**P 和 S 交换颜色。    **解析：**此时通过 N 的路径多了一个黑色节点（P），同时，通过 S 的路径的黑色节点个数不变，不违反所有性质，结束。  
   **case 4：**N 为 P 的左孩子，S 为黑，SR 为红，P 和 SL 任意颜色，如图：  
![](https://img-blog.csdn.net/20150810223401298)  
   **操作：**P 和 S 交换颜色，左旋，并把 SR 变为黑。    **解析：**此时通过 N 的路径多了一个黑色节点（P）；而 S 和 P 交换颜色并左旋之后，使通过 S 的路径少了一个黑色节点，但由于 SR 由红变成了黑色，因此通过 S 的路径的黑色节点个数不变，结束。  
   **case 5：**N 为 P 的左孩子，S、SR 都为黑，SL 为红，P 任意颜色，如图：  
![](https://img-blog.csdn.net/20150810223427857)    **操作：**SL 和 S 交换颜色，并右旋。    **解析：**由于这种情况下无法通过 case 4 的操作来调整好，因为 SR 本身就是黑色，不能由红变黑，增加黑色节点个数。因此，通过 SL 和 S 交换颜色并右旋，使 SL 处于 S 的最初位置，并且 SL 的右孩子为红色，变成了 case 4。